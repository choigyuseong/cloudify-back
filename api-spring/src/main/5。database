// ==================== 5. ë°ì´í„°ë² ì´ìŠ¤ (database.js) ====================
// DB ì´ˆê¸°í™”, ì €ì¥ ë“± ëª¨ë“  DB ì‘ì—…

const config = require('./1_config');
const { generateTags } = require('./2_utils');

async function initializeTables() {
  const client = await config.pool.connect();
  try {
    console.log('ğŸ“ í…Œì´ë¸” ì´ˆê¸°í™” ì¤‘...');
    
    await client.query('BEGIN');

    await client.query(`
      CREATE TABLE IF NOT EXISTS artists (
        id TEXT PRIMARY KEY,
        name TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    console.log('  âœ… artists í…Œì´ë¸” ìƒì„±');

    await client.query(`
      CREATE TABLE IF NOT EXISTS tracks (
        id TEXT PRIMARY KEY,
        name TEXT,
        artists TEXT[],
        genre TEXT,
        popularity INTEGER,
        duration_ms INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    console.log('  âœ… tracks í…Œì´ë¸” ìƒì„±');

    await client.query(`
      CREATE TABLE IF NOT EXISTS audio_features (
        track_id TEXT PRIMARY KEY,
        tempo REAL,
        key INTEGER,
        mode INTEGER,
        key_confidence REAL,
        energy REAL,
        danceability REAL,
        valence REAL,
        instrumentalness REAL,
        acousticness REAL,
        loudness REAL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (track_id) REFERENCES tracks(id) ON DELETE CASCADE
      )
    `);
    console.log('  âœ… audio_features í…Œì´ë¸” ìƒì„±');

    await client.query(`
      CREATE TABLE IF NOT EXISTS tags (
        id SERIAL PRIMARY KEY,
        track_id TEXT,
        tag_type TEXT,
        tag_value TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (track_id) REFERENCES tracks(id) ON DELETE CASCADE
      )
    `);
    console.log('  âœ… tags í…Œì´ë¸” ìƒì„±');

    await client.query(`CREATE INDEX IF NOT EXISTS idx_tracks_name ON tracks(name)`);
    await client.query(`CREATE INDEX IF NOT EXISTS idx_tracks_created_at ON tracks(created_at DESC)`);
    await client.query(`CREATE INDEX IF NOT EXISTS idx_tracks_genre ON tracks(genre)`);
    await client.query(`CREATE INDEX IF NOT EXISTS idx_tags_track_id ON tags(track_id)`);
    console.log('  âœ… ì¸ë±ìŠ¤ ìƒì„±');

    await client.query('COMMIT');
    console.log('âœ… AWS RDS í…Œì´ë¸” ìƒì„± ì™„ë£Œ\n');

  } catch (error) {
    await client.query('ROLLBACK');
    console.error('âŒ í…Œì´ë¸” ìƒì„± ì‹¤íŒ¨:', error.message);
    console.error('ìŠ¤íƒ:', error.stack);
    throw error;
  } finally {
    client.release();
  }
}

async function saveTrackComplete(trackData) {
  let client;
  
  try {
    console.log('ğŸ‘‰ DB ì—°ê²° ì‹œë„');
    client = await config.pool.connect();
    console.log('âœ… DB ì—°ê²° ì„±ê³µ');

    console.log('\nğŸ“ ì €ì¥ ì‹œì‘');
    console.log('Track ID:', trackData?.id);
    console.log('Track Name:', trackData?.name);

    await client.query('BEGIN');
    console.log('âœ… íŠ¸ëœì­ì…˜ ì‹œì‘');

    if (!trackData || !trackData.id) {
      throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ íŠ¸ë™ ë°ì´í„°');
    }
    
    // ì•„í‹°ìŠ¤íŠ¸ ì €ì¥
    if (trackData.artists && trackData.artists.length > 0) {
      console.log(`ğŸ“Œ ì•„í‹°ìŠ¤íŠ¸ ì €ì¥ ì¤‘ (${trackData.artists.length}ëª…)`);
      
      for (const artistName of trackData.artists) {
        const artistId = artistName.toLowerCase().replace(/\s+/g, '-');
        await client.query(`
          INSERT INTO artists (id, name) VALUES ($1, $2)
          ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name
        `, [artistId, artistName]);
        
        console.log(`   âœ… ${artistName}`);
      }
    }
    
    // íŠ¸ë™ ì €ì¥
    console.log(`ğŸ“Œ íŠ¸ë™ ì €ì¥ ì¤‘`);
    const trackResult = await client.query(`
      INSERT INTO tracks (id, name, artists, genre, popularity, duration_ms)
      VALUES ($1, $2, $3, $4, $5, $6)
      ON CONFLICT (id) DO UPDATE SET
        name = EXCLUDED.name,
        artists = EXCLUDED.artists,
        genre = EXCLUDED.genre,
        popularity = EXCLUDED.popularity
    `, [
      trackData.id,
      trackData.name,
      trackData.artists || [],
      trackData.genre || null,
      trackData.popularity || 0,
      trackData.duration_ms || 0
    ]);
    console.log(`   âœ… ì™„ë£Œ (ì˜í–¥ í–‰: ${trackResult.rowCount})`);
    
    // Audio Features ì €ì¥
    if (trackData.features) {
      console.log(`ğŸ“Œ Audio Features ì €ì¥ ì¤‘`);
      const f = trackData.features;
      
      const featureResult = await client.query(`
        INSERT INTO audio_features (
          track_id, tempo, key, mode, key_confidence, energy, 
          danceability, valence, instrumentalness, acousticness, loudness
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        ON CONFLICT (track_id) DO UPDATE SET
          tempo = EXCLUDED.tempo,
          energy = EXCLUDED.energy,
          danceability = EXCLUDED.danceability
      `, [
        trackData.id,
        f.tempo || null,
        f.key || null,
        f.mode || null,
        f.key_confidence || null,
        f.energy || null,
        f.danceability || null,
        f.valence || null,
        f.instrumentalness || null,
        f.acousticness || null,
        f.loudness || null
      ]);
      
      console.log(`   âœ… ì™„ë£Œ (ì˜í–¥ í–‰: ${featureResult.rowCount})`);
      
      // íƒœê·¸ ìƒì„± ë° ì €ì¥
      const tags = generateTags(f);
      if (trackData.genre) tags.push(`ì¥ë¥´: ${trackData.genre}`);
      
      await client.query(`DELETE FROM tags WHERE track_id = $1`, [trackData.id]);
      for (const tag of tags) {
        const parts = tag.split(': ');
        if (parts.length === 2) {
          await client.query(
            `INSERT INTO tags (track_id, tag_type, tag_value) VALUES ($1, $2, $3)`,
            [trackData.id, parts[0], parts[1]]
          );
        }
      }
      
      console.log(`   âœ… íƒœê·¸ ì €ì¥ (${tags.length}ê°œ)`);
    }
    
    await client.query('COMMIT');
    console.log('âœ… íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì™„ë£Œ\n');
    return { success: true };
    
  } catch (error) {
    console.error('âŒ saveTrackComplete ì „ì²´ ì‹¤íŒ¨:', error.message);
    console.error(error.stack);
    
    if (client) {
      try {
        await client.query('ROLLBACK');
        console.log('âœ… ë¡¤ë°± ì™„ë£Œ');
      } catch (rbErr) {
        console.error('âŒ ë¡¤ë°± ì‹¤íŒ¨:', rbErr.message);
      }
    }
    return { success: false, error: error.message };
    
  } finally {
    if (client) client.release();
  }
}

async function getAllTracks() {
  try {
    const result = await config.pool.query(`
      SELECT t.*, af.*
      FROM tracks t
      LEFT JOIN audio_features af ON t.id = af.track_id
      ORDER BY t.created_at DESC
      LIMIT 100
    `);
    return result.rows;
  } catch (error) {
    console.error('âŒ DB ì¡°íšŒ ì‹¤íŒ¨:', error.message);
    return [];
  }
}

async function getStats() {
  try {
    const result = await config.pool.query(`
      SELECT 
        (SELECT COUNT(*) FROM tracks) as total,
        (SELECT AVG(tempo) FROM audio_features) as avg_tempo,
        (SELECT AVG(energy) FROM audio_features) as avg_energy,
        (SELECT COUNT(DISTINCT genre) FROM tracks WHERE genre IS NOT NULL) as genre_count
    `);
    return result.rows[0];
  } catch (error) {
    console.error('âŒ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨:', error.message);
    return null;
  }
}

module.exports = {
  initializeTables,
  saveTrackComplete,
  getAllTracks,
  getStats
};

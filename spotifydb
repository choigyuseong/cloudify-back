// í•„ìš”í•œ íŒ¨í‚¤ì§€: npm install express axios sqlite3

const express = require('express');
const axios = require('axios');
const querystring = require('querystring');
const sqlite3 = require('sqlite3').verbose();

const app = express();
const PORT = 8888;

// Spotify ì•± ì •ë³´
const CLIENT_ID = '7a22c29754bd49509e0476f93febd709';
const CLIENT_SECRET = '667186f0278b465c97e8a524d508a79f';
const REDIRECT_URI = 'http://127.0.0.1:8888/callback';
const SCOPE = 'user-read-private user-read-email user-top-read playlist-read-private user-read-recently-played';

// ==================== ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • ====================

// ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±/ì—°ê²°
const db = new sqlite3.Database('./spotify_data.db', (err) => {
  if (err) {
    console.error('âŒ DB ì—°ê²° ì‹¤íŒ¨:', err);
  } else {
    console.log('âœ… DB ì—°ê²° ì„±ê³µ: spotify_data.db');
  }
});

// í…Œì´ë¸” ìƒì„±
db.serialize(() => {
  // ì‚¬ìš©ì í…Œì´ë¸”
  db.run(`
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY,
      display_name TEXT,
      email TEXT,
      country TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // íŠ¸ë™ í…Œì´ë¸”
  db.run(`
    CREATE TABLE IF NOT EXISTS tracks (
      id TEXT PRIMARY KEY,
      name TEXT,
      artist_name TEXT,
      artist_id TEXT,
      album_name TEXT,
      album_id TEXT,
      duration_ms INTEGER,
      popularity INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // ì˜¤ë””ì˜¤ íŠ¹ì„± í…Œì´ë¸”
  db.run(`
    CREATE TABLE IF NOT EXISTS audio_features (
      track_id TEXT PRIMARY KEY,
      tempo REAL,
      energy REAL,
      valence REAL,
      danceability REAL,
      acousticness REAL,
      instrumentalness REAL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (track_id) REFERENCES tracks(id)
    )
  `);

  // íƒœê·¸ í…Œì´ë¸”
  db.run(`
    CREATE TABLE IF NOT EXISTS tags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      track_id TEXT,
      tag_type TEXT,
      tag_value TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (track_id) REFERENCES tracks(id)
    )
  `);

  // ì‚¬ìš©ì ìƒìœ„ íŠ¸ë™ í…Œì´ë¸”
  db.run(`
    CREATE TABLE IF NOT EXISTS user_top_tracks (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id TEXT,
      track_id TEXT,
      rank INTEGER,
      saved_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id),
      FOREIGN KEY (track_id) REFERENCES tracks(id)
    )
  `);

  console.log('âœ… í…Œì´ë¸” ìƒì„± ì™„ë£Œ');
});

// ==================== ì¸ì¦ ê´€ë ¨ ====================

app.get('/', (req, res) => {
  res.redirect('/login');
});

app.get('/login', (req, res) => {
  const authUrl = 'https://accounts.spotify.com/authorize?' + 
    querystring.stringify({
      response_type: 'code',
      client_id: CLIENT_ID,
      scope: SCOPE,
      redirect_uri: REDIRECT_URI,
    });
  res.redirect(authUrl);
});

app.get('/callback', async (req, res) => {
  const code = req.query.code || null;

  try {
    const response = await axios.post(
      'https://accounts.spotify.com/api/token',
      querystring.stringify({
        code: code,
        redirect_uri: REDIRECT_URI,
        grant_type: 'authorization_code',
      }),
      {
        headers: {
          'Authorization': 'Basic ' + Buffer.from(CLIENT_ID + ':' + CLIENT_SECRET).toString('base64'),
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      }
    );

    const { access_token } = response.data;
    res.redirect('/dashboard?access_token=' + access_token);
    
  } catch (error) {
    console.error('Error:', error.response?.data || error.message);
    res.send('Error during authentication');
  }
});

// ==================== ëŒ€ì‹œë³´ë“œ ====================

app.get('/dashboard', async (req, res) => {
  const access_token = req.query.access_token;

  try {
    const userResponse = await axios.get('https://api.spotify.com/v1/me', {
      headers: { 'Authorization': 'Bearer ' + access_token }
    });

    // ì‚¬ìš©ì ì •ë³´ DBì— ì €ì¥
    const user = userResponse.data;
    db.run(`
      INSERT OR REPLACE INTO users (id, display_name, email, country)
      VALUES (?, ?, ?, ?)
    `, [user.id, user.display_name, user.email, user.country], (err) => {
      if (err) console.error('âŒ ì‚¬ìš©ì ì €ì¥ ì‹¤íŒ¨:', err);
      else console.log('âœ… ì‚¬ìš©ì ì €ì¥ ì™„ë£Œ:', user.display_name);
    });

    res.send(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Spotify Dashboard</title>
        <style>
          body { font-family: Arial; max-width: 1200px; margin: 50px auto; padding: 20px; }
          h1 { color: #1DB954; }
          .menu { margin: 30px 0; }
          .menu a { 
            display: inline-block; 
            margin: 10px; 
            padding: 15px 25px; 
            background: #1DB954; 
            color: white; 
            text-decoration: none; 
            border-radius: 5px;
          }
          .menu a:hover { background: #1ed760; }
        </style>
      </head>
      <body>
        <h1>Welcome, ${user.display_name}! ğŸµ</h1>
        <p>âœ… ì‚¬ìš©ì ì •ë³´ê°€ DBì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!</p>
        
        <div class="menu">
          <h2>ê¸°ëŠ¥ ë©”ë‰´</h2>
          <a href="/save-top-tracks?access_token=${access_token}">ìƒìœ„ íŠ¸ë™ ì €ì¥í•˜ê¸°</a>
          <a href="/search-and-save?access_token=${access_token}">ê²€ìƒ‰ & ì €ì¥</a>
          <a href="/view-db?access_token=${access_token}">DB ì¡°íšŒ</a>
          <a href="/save-all-analysis?access_token=${access_token}">ì „ì²´ ë¶„ì„ & ì €ì¥</a>
        </div>
      </body>
      </html>
    `);

  } catch (error) {
    console.error('Error:', error.response?.data || error.message);
    res.send('Error fetching user data');
  }
});

// ==================== ìƒìœ„ íŠ¸ë™ ì €ì¥ ====================

app.get('/save-top-tracks', async (req, res) => {
  const access_token = req.query.access_token;

  try {
    // ì‚¬ìš©ì ì •ë³´
    const userResponse = await axios.get('https://api.spotify.com/v1/me', {
      headers: { 'Authorization': 'Bearer ' + access_token }
    });
    const userId = userResponse.data.id;

    // ìƒìœ„ íŠ¸ë™
    const topTracksResponse = await axios.get(
      'https://api.spotify.com/v1/me/top/tracks?limit=10',
      { headers: { 'Authorization': 'Bearer ' + access_token } }
    );

    const tracks = topTracksResponse.data.items;
    let savedCount = 0;

    // ê° íŠ¸ë™ ì €ì¥
    for (let i = 0; i < tracks.length; i++) {
      const track = tracks[i];
      
      // íŠ¸ë™ ì •ë³´ ì €ì¥
      await new Promise((resolve, reject) => {
        db.run(`
          INSERT OR REPLACE INTO tracks (id, name, artist_name, artist_id, album_name, album_id, duration_ms, popularity)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `, [
          track.id,
          track.name,
          track.artists[0].name,
          track.artists[0].id,
          track.album.name,
          track.album.id,
          track.duration_ms,
          track.popularity
        ], (err) => {
          if (err) reject(err);
          else resolve();
        });
      });

      // ì‚¬ìš©ì ìƒìœ„ íŠ¸ë™ ê¸°ë¡
      await new Promise((resolve, reject) => {
        db.run(`
          INSERT INTO user_top_tracks (user_id, track_id, rank)
          VALUES (?, ?, ?)
        `, [userId, track.id, i + 1], (err) => {
          if (err) reject(err);
          else resolve();
        });
      });

      savedCount++;
      console.log(`âœ… ì €ì¥ ì™„ë£Œ (${savedCount}/${tracks.length}): ${track.name}`);
    }

    res.send(`
      <!DOCTYPE html>
      <html>
      <head><meta charset="UTF-8"><title>ì €ì¥ ì™„ë£Œ</title></head>
      <body style="font-family: Arial; max-width: 800px; margin: 50px auto; padding: 20px;">
        <h1>âœ… ${savedCount}ê°œ íŠ¸ë™ ì €ì¥ ì™„ë£Œ!</h1>
        <ul>
          ${tracks.map((t, i) => `<li>${i + 1}. ${t.name} - ${t.artists[0].name}</li>`).join('')}
        </ul>
        <a href="/dashboard?access_token=${access_token}" style="color: #1DB954;">â† ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°</a>
      </body>
      </html>
    `);

  } catch (error) {
    console.error('Error:', error);
    res.send('ì €ì¥ ì‹¤íŒ¨: ' + error.message);
  }
});

// ==================== ê²€ìƒ‰ & ì €ì¥ ====================

app.get('/search-and-save', (req, res) => {
  const access_token = req.query.access_token;
  res.send(`
    <!DOCTYPE html>
    <html>
    <head><meta charset="UTF-8"><title>ê²€ìƒ‰ & ì €ì¥</title></head>
    <body style="font-family: Arial; max-width: 800px; margin: 50px auto; padding: 20px;">
      <h1>ğŸ” ê²€ìƒ‰ & DB ì €ì¥</h1>
      <form action="/search-save-result" method="GET">
        <input type="hidden" name="access_token" value="${access_token}">
        <input type="text" name="q" placeholder="ê³¡ ì´ë¦„ ì…ë ¥" style="width: 60%; padding: 10px; font-size: 16px;" required>
        <button type="submit" style="padding: 10px 20px; font-size: 16px; background: #1DB954; color: white; border: none;">ê²€ìƒ‰ & ì €ì¥</button>
      </form>
      <br>
      <a href="/dashboard?access_token=${access_token}" style="color: #1DB954;">â† ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°</a>
    </body>
    </html>
  `);
});

app.get('/search-save-result', async (req, res) => {
  const access_token = req.query.access_token;
  const query = req.query.q;

  try {
    const searchResponse = await axios.get(
      `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=5`,
      { headers: { 'Authorization': 'Bearer ' + access_token } }
    );

    const tracks = searchResponse.data.tracks.items;

    // ê° íŠ¸ë™ + ì˜¤ë””ì˜¤ íŠ¹ì„± ì €ì¥
    for (const track of tracks) {
      // íŠ¸ë™ ì €ì¥
      await saveTrack(track);

      // ì˜¤ë””ì˜¤ íŠ¹ì„± ê°€ì ¸ì˜¤ê¸° & ì €ì¥
      const audioResponse = await axios.get(
        `https://api.spotify.com/v1/audio-features/${track.id}`,
        { headers: { 'Authorization': 'Bearer ' + access_token } }
      );
      
      await saveAudioFeatures(audioResponse.data);

      // íƒœê·¸ ìƒì„± & ì €ì¥
      const tags = generateTags(audioResponse.data);
      await saveTags(track.id, tags);
    }

    res.send(`
      <!DOCTYPE html>
      <html>
      <head><meta charset="UTF-8"><title>ì €ì¥ ì™„ë£Œ</title></head>
      <body style="font-family: Arial; max-width: 800px; margin: 50px auto; padding: 20px;">
        <h1>âœ… ${tracks.length}ê°œ íŠ¸ë™ + ë¶„ì„ ë°ì´í„° ì €ì¥ ì™„ë£Œ!</h1>
        <ul>
          ${tracks.map(t => `<li>${t.name} - ${t.artists[0].name}</li>`).join('')}
        </ul>
        <a href="/search-and-save?access_token=${access_token}">ë‹¤ì‹œ ê²€ìƒ‰</a> | 
        <a href="/view-db?access_token=${access_token}">DB ì¡°íšŒ</a>
      </body>
      </html>
    `);

  } catch (error) {
    console.error('Error:', error);
    res.send('ì €ì¥ ì‹¤íŒ¨: ' + error.message);
  }
});

// ==================== DB ì¡°íšŒ ====================

app.get('/view-db', (req, res) => {
  const access_token = req.query.access_token;

  // ëª¨ë“  íŠ¸ë™ ì¡°íšŒ
  db.all(`
    SELECT t.*, af.tempo, af.energy, af.valence
    FROM tracks t
    LEFT JOIN audio_features af ON t.id = af.track_id
    ORDER BY t.created_at DESC
    LIMIT 50
  `, [], (err, tracks) => {
    if (err) {
      res.send('DB ì¡°íšŒ ì‹¤íŒ¨: ' + err.message);
      return;
    }

    // ê° íŠ¸ë™ì˜ íƒœê·¸ ì¡°íšŒ
    const trackPromises = tracks.map(track => {
      return new Promise((resolve) => {
        db.all(`SELECT tag_type, tag_value FROM tags WHERE track_id = ?`, [track.id], (err, tags) => {
          track.tags = tags || [];
          resolve(track);
        });
      });
    });

    Promise.all(trackPromises).then(tracksWithTags => {
      res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>DB ì¡°íšŒ</title>
          <style>
            body { font-family: Arial; max-width: 1400px; margin: 50px auto; padding: 20px; }
            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
            th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
            th { background: #1DB954; color: white; }
            .tag { display: inline-block; background: #1DB954; color: white; padding: 3px 8px; margin: 2px; border-radius: 10px; font-size: 12px; }
          </style>
        </head>
        <body>
          <h1>ğŸ“Š ì €ì¥ëœ ë°ì´í„° (ì´ ${tracksWithTags.length}ê°œ)</h1>
          <table>
            <tr>
              <th>ê³¡ëª…</th>
              <th>ì•„í‹°ìŠ¤íŠ¸</th>
              <th>ì•¨ë²”</th>
              <th>í…œí¬</th>
              <th>ì—ë„ˆì§€</th>
              <th>ê¸ì •ë„</th>
              <th>íƒœê·¸</th>
              <th>ì €ì¥ì¼</th>
            </tr>
            ${tracksWithTags.map(t => `
              <tr>
                <td><strong>${t.name}</strong></td>
                <td>${t.artist_name}</td>
                <td>${t.album_name}</td>
                <td>${t.tempo ? Math.round(t.tempo) : '-'}</td>
                <td>${t.energy ? (t.energy * 100).toFixed(0) + '%' : '-'}</td>
                <td>${t.valence ? (t.valence * 100).toFixed(0) + '%' : '-'}</td>
                <td>${t.tags.map(tag => `<span class="tag">${tag.tag_value}</span>`).join('')}</td>
                <td>${new Date(t.created_at).toLocaleDateString('ko-KR')}</td>
              </tr>
            `).join('')}
          </table>
          <a href="/dashboard?access_token=${access_token}" style="color: #1DB954;">â† ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°</a>
        </body>
        </html>
      `);
    });
  });
});

// ==================== ì „ì²´ ë¶„ì„ & ì €ì¥ ====================

app.get('/save-all-analysis', async (req, res) => {
  const access_token = req.query.access_token;

  try {
    // ìƒìœ„ 10ê°œ íŠ¸ë™
    const topTracksResponse = await axios.get(
      'https://api.spotify.com/v1/me/top/tracks?limit=10',
      { headers: { 'Authorization': 'Bearer ' + access_token } }
    );

    const tracks = topTracksResponse.data.items;
    const trackIds = tracks.map(t => t.id).join(',');

    // ì˜¤ë””ì˜¤ íŠ¹ì„± ì¼ê´„ ì¡°íšŒ
    const audioResponse = await axios.get(
      `https://api.spotify.com/v1/audio-features?ids=${trackIds}`,
      { headers: { 'Authorization': 'Bearer ' + access_token } }
    );

    // ì €ì¥
    for (let i = 0; i < tracks.length; i++) {
      await saveTrack(tracks[i]);
      await saveAudioFeatures(audioResponse.data.audio_features[i]);
      const tags = generateTags(audioResponse.data.audio_features[i]);
      await saveTags(tracks[i].id, tags);
    }

    res.send(`
      <!DOCTYPE html>
      <html>
      <head><meta charset="UTF-8"><title>ë¶„ì„ ì™„ë£Œ</title></head>
      <body style="font-family: Arial; max-width: 800px; margin: 50px auto; padding: 20px;">
        <h1>âœ… ${tracks.length}ê°œ íŠ¸ë™ ë¶„ì„ & ì €ì¥ ì™„ë£Œ!</h1>
        <p>íŠ¸ë™ ì •ë³´, ì˜¤ë””ì˜¤ íŠ¹ì„±, íƒœê·¸ê°€ ëª¨ë‘ DBì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
        <a href="/view-db?access_token=${access_token}">DB ì¡°íšŒí•˜ê¸°</a>
      </body>
      </html>
    `);

  } catch (error) {
    console.error('Error:', error);
    res.send('ë¶„ì„ ì‹¤íŒ¨: ' + error.message);
  }
});

// ==================== í—¬í¼ í•¨ìˆ˜ ====================

function saveTrack(track) {
  return new Promise((resolve, reject) => {
    db.run(`
      INSERT OR REPLACE INTO tracks (id, name, artist_name, artist_id, album_name, album_id, duration_ms, popularity)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      track.id,
      track.name,
      track.artists[0].name,
      track.artists[0].id,
      track.album.name,
      track.album.id,
      track.duration_ms,
      track.popularity
    ], (err) => {
      if (err) reject(err);
      else {
        console.log(`âœ… íŠ¸ë™ ì €ì¥: ${track.name}`);
        resolve();
      }
    });
  });
}

function saveAudioFeatures(audio) {
  return new Promise((resolve, reject) => {
    db.run(`
      INSERT OR REPLACE INTO audio_features (track_id, tempo, energy, valence, danceability, acousticness, instrumentalness)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `, [
      audio.id,
      audio.tempo,
      audio.energy,
      audio.valence,
      audio.danceability,
      audio.acousticness,
      audio.instrumentalness
    ], (err) => {
      if (err) reject(err);
      else {
        console.log(`âœ… ì˜¤ë””ì˜¤ íŠ¹ì„± ì €ì¥: ${audio.id}`);
        resolve();
      }
    });
  });
}

function saveTags(trackId, tags) {
  return new Promise((resolve, reject) => {
    // ê¸°ì¡´ íƒœê·¸ ì‚­ì œ
    db.run(`DELETE FROM tags WHERE track_id = ?`, [trackId], (err) => {
      if (err) {
        reject(err);
        return;
      }

      // ìƒˆ íƒœê·¸ ì €ì¥
      const stmt = db.prepare(`INSERT INTO tags (track_id, tag_type, tag_value) VALUES (?, ?, ?)`);
      
      for (const tag of tags) {
        const [type, value] = tag.split(': ');
        stmt.run(trackId, type, value);
      }
      
      stmt.finalize((err) => {
        if (err) reject(err);
        else {
          console.log(`âœ… íƒœê·¸ ì €ì¥: ${trackId} (${tags.length}ê°œ)`);
          resolve();
        }
      });
    });
  });
}

function generateTags(audioFeatures) {
  const tags = [];
  const { tempo, energy, valence, danceability, acousticness, instrumentalness } = audioFeatures;

  if (tempo < 90) tags.push('í…œí¬: ëŠë¦¼');
  else if (tempo <= 120) tags.push('í…œí¬: ì¤‘ê°„');
  else tags.push('í…œí¬: ë¹ ë¦„');

  if (energy < 0.40 && valence >= 0.50) tags.push('ë¶„ìœ„ê¸°: í¸ì•ˆí•¨');
  if (energy < 0.40 && valence < 0.50) tags.push('ë¶„ìœ„ê¸°: ì°¨ë¶„í•¨');
  if (energy >= 0.60 && valence >= 0.60) tags.push('ë¶„ìœ„ê¸°: ì‹ ë‚¨');
  if (instrumentalness >= 0.60) tags.push('ë¶„ìœ„ê¸°: ì§‘ì¤‘');

  if (energy < 0.55 && tempo < 115) tags.push('íƒ€ì…: ì°¨ë¶„');
  else tags.push('íƒ€ì…: í™œë°œ');

  if (tempo >= 60 && tempo <= 100 && energy < 0.5 && instrumentalness >= 0.5) {
    tags.push('í™œë™: ê³µë¶€/ì§‘ì¤‘');
  }
  if (tempo > 120 && energy >= 0.7 && danceability >= 0.6) {
    tags.push('í™œë™: ìš´ë™');
  }
  if (tempo >= 70 && tempo <= 110 && energy < 0.5) {
    tags.push('í™œë™: íœ´ì‹');
  }

  return tags;
}

// ==================== ì„œë²„ ì‹œì‘ ====================

app.listen(PORT, () => {
  console.log(`ğŸµ ì„œë²„ ì‹¤í–‰: http://localhost:${PORT}`);
  console.log(`ğŸ”‘ ë¡œê·¸ì¸: http://localhost:${PORT}/login`);
});
